Boost Spring Music
============

This is forked from [Spring Music](https://github.com/cloudfoundry-samples/spring-music) to demonstrate using Boost with a Spring Boot application.

## Building with Boost

Boost will hook into the build lifecycle by adding its tasks to the project's task graph.

You don't have to change anything in your project aside from applying the Boost plugin in order to make use of Boost.

In this case, we just had to add the plugin to our build script:

```
buildscript {

...

    repositories {
        jcenter()
        mavenCentral()
        mavenLocal()
        maven { url "https://repo.spring.io/plugins-release" }
    }

    dependencies {
        classpath "org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}"
        classpath "io.openliberty.boost:boost-gradle-plugin:0.1"
    }
}

...

apply plugin: 'boost'
```

Once the plugin is added, the project can be built with something like `./gradlew clean assemble` or `./gradlew clean build`.

In this project, the Boost plugin configures its tasks to run based on the `bootJar` task. This results in the Spring Uber JAR being thinned and repackaged by Boost returning a runnable JAR with the Spring Boost app on a Liberty server.

To run the JAR use:

```
java -jar build/libs/spring-music-1.0.jar
```

## Boost Tasks

If you don't want to run the whole build you can call the individual Boost tasks.

The task `boostPackage` is what we used to take the Spring Uber JAR and create a runnable Liberty JAR.

If you want to create a Docker container there are the `boostDockerBuild` and `boostDockerPush` tasks.

`boostDockerBuild` creates a Docker image based on the project configuration and `boostDockerPush` will push an image generated by `boostDockerBuild` to a configured registry.

If you would like to configure Docker related properties in Boost you can use the `docker` closure. Here is an example of what that might look like in your build:

```
boost {
    docker {
        repository = 'localhost:5000/boost-spring-music' //The registry/image name.
        dockerizer = 'classpath' //Chooses which base Docker image to use.
    }
}
```

Packaging can be configured in a similar way, but this is just used if you'd like a different package name.

```
boost {
    packaging {
        packageName = 'extensionTest'
    }
}
```